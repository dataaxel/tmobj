<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>tmobj – Objektigenkänning</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <style>
    :root { --pad: 14px; --radius: 16px; }
    body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#0b0f17; color:#fff; }
    .wrap { height: 100svh; display: grid; grid-template-rows: 1fr auto; }
    .stage { position: relative; overflow: hidden; background:#000; border-bottom-left-radius:24px; border-bottom-right-radius:24px; }
    video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    .hud { position:absolute; left:var(--pad); right:var(--pad); top:var(--pad); display:grid; gap:10px; pointer-events:none; }
    .card {
      backdrop-filter: blur(10px);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: var(--radius);
      padding: 12px 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .title { font-size: 14px; opacity: 0.9; margin-bottom: 4px; }
    .big { font-size: 22px; font-weight: 750; line-height: 1.2; }
    .row { display:flex; justify-content: space-between; gap: 10px; margin-top: 8px; font-size: 13px; opacity: 0.92; }
    .bar { height:10px; border-radius:999px; background: rgba(255,255,255,0.12); overflow:hidden; margin-top:10px; }
    .bar > div { height:100%; width:0%; background: linear-gradient(90deg,#37d67a,#00c2ff); border-radius:999px; transition: width 160ms ease; }
    .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
    .bottom { padding: var(--pad); display:grid; gap:10px; background:#0b0f17; }
    .btns { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    button { border:0; border-radius: 16px; padding: 14px 16px; font-size: 16px; font-weight: 650; background:#1b2436; color:#fff; }
    button.primary { background:#2563eb; }
    button:disabled { opacity:0.55; }
    .statusline { font-size: 13px; opacity: 0.85; display:flex; justify-content: space-between; gap:10px; flex-wrap: wrap; }
    .hint { font-size: 12px; opacity: 0.68; line-height: 1.35; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>

      <div class="hud">
        <div class="card">
          <div class="title">Top prediction</div>
          <div class="big" id="topLabel">—</div>
          <div class="row">
            <div>Confidence</div>
            <div class="mono" id="topConf">—</div>
          </div>
          <div class="bar"><div id="confBar"></div></div>
          <div class="row" id="top3" style="margin-top:10px; opacity:0.85;">
            <div class="mono">—</div><div class="mono">—</div><div class="mono">—</div>
          </div>
        </div>

        <div class="card">
          <div class="row"><div>Status</div><div class="mono" id="status">Init…</div></div>
          <div class="row"><div>FPS</div><div class="mono" id="fps">—</div></div>
          <div class="row"><div>Infer</div><div class="mono" id="ifps">—</div></div>
        </div>
      </div>
    </div>

    <div class="bottom">
      <div class="btns">
        <button class="primary" id="startBtn">Starta kamera</button>
        <button id="stopBtn" disabled>Stoppa</button>
      </div>

      <div class="statusline">
        <div>Model: <span class="mono" id="modelState">loading…</span></div>
        <div>Input: <span class="mono">224×224×3</span></div>
        <div>Mode: <span class="mono">GraphModel</span></div>
      </div>

      <div class="hint" id="hint">
        Tips: För mindre flimmer kör vi inference i lägre takt + glidande medel.
      </div>
    </div>
  </div>

<script>
  // =================== KONFIG ===================
  const MODEL_URL  = "./web_model/model.json";
  const LABELS_URL = "./labels.txt";
  const INPUT_H = 224, INPUT_W = 224;

  // Normalisering
  const NORMALIZE_MODE = "zero_to_one"; // eller "minus_one_to_one"

  // ---- Anti-flimmer inställningar ----
  const INFER_HZ = 10;              // kör modellen ~10 ggr/sek (minskar jitter & sparar CPU)
  const EMA_ALPHA = 0.35;           // 0..1 (högre = snabbare reaktion, lägre = stabilare)
  const SWITCH_CONFIRM = 3;         // ny label måste vara bäst i N infer-steg innan vi byter
  const HOLD_MIN_CONF = 0.55;       // byt bara om nya labelns conf är minst detta (justera vid behov)

  // =================== UI refs ===================
  const video = document.getElementById("video");
  const canvas = document.getElementById("overlay");
  const ctx = canvas.getContext("2d");

  const topLabelEl = document.getElementById("topLabel");
  const topConfEl  = document.getElementById("topConf");
  const confBarEl  = document.getElementById("confBar");
  const top3El     = document.getElementById("top3");

  const statusEl   = document.getElementById("status");
  const fpsEl      = document.getElementById("fps");
  const ifpsEl     = document.getElementById("ifps");
  const modelState = document.getElementById("modelState");
  const hintEl     = document.getElementById("hint");

  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");

  // =================== STATE ===================
  let model = null;
  let labels = [];
  let running = false;
  let stream = null;

  // Inference throttling
  let lastInferAt = 0;
  let inferCount = 0;
  let inferFps = 0;
  let inferFpsT0 = 0;

  // EMA smoothing av sannolikheter
  let ema = null;                 // Float32Array [numClasses]
  let numClasses = 0;

  // Hysteresis/låsning
  let stableIdx = -1;
  let candidateIdx = -1;
  let candidateStreak = 0;

  function setStatus(s) { statusEl.textContent = s; }
  function setHint(s) { hintEl.textContent = s; }

  async function loadLabels() {
    const r = await fetch(LABELS_URL, { cache: "no-store" });
    if (!r.ok) throw new Error(`labels.txt kunde inte laddas (HTTP ${r.status}).`);
    const txt = await r.text();
    labels = txt.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
    if (!labels.length) throw new Error("labels.txt är tom eller kunde inte tolkas.");
  }

  async function loadModel() {
    modelState.textContent = "loading…";
    model = await tf.loadGraphModel(MODEL_URL);
    modelState.textContent = "ready";
  }

  function resizeCanvas() {
    canvas.width  = video.videoWidth || 0;
    canvas.height = video.videoHeight || 0;
  }

  function stopCamera() {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
  }

  function preprocess(imgTensor) {
    let x = imgTensor.toFloat();
    if (NORMALIZE_MODE === "minus_one_to_one") x = x.div(127.5).sub(1.0);
    else x = x.div(255.0);
    return x;
  }

  function argmax(arr) {
    let max = -Infinity, idx = -1;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] > max) { max = arr[i]; idx = i; }
    }
    return [idx, max];
  }

  function topK(probs, k=3) {
    const items = Array.from(probs).map((p, i) => ({i, p}));
    items.sort((a,b) => b.p - a.p);
    return items.slice(0, k);
  }

  async function startCameraRobust() {
    if (!window.isSecureContext) throw new Error("Kamera kräver HTTPS (secure context).");
    if (!navigator.mediaDevices?.getUserMedia) throw new Error("getUserMedia saknas i denna webbläsare/miljö.");

    stopCamera();

    const tries = [
      { audio: false, video: { facingMode: { exact: "environment" } } },
      { audio: false, video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } } },
      { audio: false, video: { facingMode: { exact: "user" } } },
      { audio: false, video: true }
    ];

    let lastErr = null;
    for (const c of tries) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(c);
        video.srcObject = stream;
        await video.play();
        await new Promise((resolve) => {
          if (video.readyState >= 2) return resolve();
          video.onloadedmetadata = () => resolve();
        });
        resizeCanvas();
        return;
      } catch (e) {
        lastErr = e;
        const name = e?.name || "";
        if (name === "NotAllowedError" || name === "PermissionDeniedError") break;
      }
    }
    throw new Error(`${lastErr?.name || "Error"}: ${lastErr?.message || lastErr}`);
  }

  function resetSmoothing(nClasses) {
    numClasses = nClasses;
    ema = new Float32Array(numClasses);
    stableIdx = -1;
    candidateIdx = -1;
    candidateStreak = 0;
  }

  function emaUpdate(rawProbs) {
    // rawProbs: JS array length = numClasses
    if (!ema || ema.length !== rawProbs.length) resetSmoothing(rawProbs.length);

    for (let i = 0; i < rawProbs.length; i++) {
      const x = rawProbs[i];
      ema[i] = EMA_ALPHA * x + (1 - EMA_ALPHA) * ema[i];
    }
    return ema;
  }

  function applyHysteresis(smoothedProbs) {
    const [bestIdx, bestP] = argmax(smoothedProbs);

    if (stableIdx === -1) {
      stableIdx = bestIdx;
      candidateIdx = bestIdx;
      candidateStreak = 0;
      return [stableIdx, bestP];
    }

    if (bestIdx === stableIdx) {
      // vi är kvar på samma label → nollställ kandidat
      candidateIdx = bestIdx;
      candidateStreak = 0;
      return [stableIdx, bestP];
    }

    // Ny kandidat
    if (candidateIdx !== bestIdx) {
      candidateIdx = bestIdx;
      candidateStreak = 1;
    } else {
      candidateStreak += 1;
    }

    // Byt först om:
    // 1) kandidatlabeleln varit bäst flera steg
    // 2) och conf är rimligt hög (minskar flimmer vid osäkerhet)
    if (candidateStreak >= SWITCH_CONFIRM && bestP >= HOLD_MIN_CONF) {
      stableIdx = candidateIdx;
      candidateStreak = 0;
    }

    return [stableIdx, smoothedProbs[stableIdx]];
  }

  function updateUI(stableIdx, stableP, probsForTopList) {
    const label = labels[stableIdx] ?? `class_${stableIdx}`;
    topLabelEl.textContent = label;
    topConfEl.textContent = (stableP * 100).toFixed(1) + "%";
    confBarEl.style.width = Math.max(0, Math.min(100, stableP * 100)) + "%";

    const t3 = topK(probsForTopList, 3).map(x => {
      const name = labels[x.i] ?? `class_${x.i}`;
      return `${name}:${(x.p * 100).toFixed(0)}%`;
    });
    top3El.innerHTML = `<div class="mono">${t3[0]||"—"}</div><div class="mono">${t3[1]||"—"}</div><div class="mono">${t3[2]||"—"}</div>`;
  }

  function drawOverlay() {
    if (!canvas.width || !canvas.height) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    ctx.strokeRect(canvas.width*0.12, canvas.height*0.22, canvas.width*0.76, canvas.height*0.56);
  }

  function predictOnce() {
    // returnerar JS array probs
    return tf.tidy(() => {
      let img = tf.browser.fromPixels(video);
      img = tf.image.resizeBilinear(img, [INPUT_H, INPUT_W], true);
      img = preprocess(img);
      img = img.expandDims(0);

      const out = model.execute(img);

      let t = out;
      if (Array.isArray(out)) t = out[0];
      else if (out && typeof out === "object" && typeof out.dataSync !== "function") {
        const k = Object.keys(out)[0];
        t = out[k];
      }

      const arr = t.squeeze().arraySync();
      return arr;
    });
  }

  async function loop(now) {
    if (!running) return;

    // Visa overlay i full fps
    drawOverlay();

    // UI-fps
    if (!loop._t0) loop._t0 = now;
    if (!loop._frames) loop._frames = 0;
    loop._frames += 1;
    const dtUI = now - loop._t0;
    if (dtUI >= 1000) {
      fpsEl.textContent = (loop._frames * 1000 / dtUI).toFixed(1);
      loop._frames = 0;
      loop._t0 = now;
    }

    // Throttle inference
    const minInterval = 1000 / INFER_HZ;
    if (now - lastInferAt >= minInterval) {
      lastInferAt = now;

      let raw;
      try {
        raw = predictOnce();
      } catch (e) {
        console.error(e);
        setStatus("Predict error");
        running = false;
        stopBtn.disabled = true;
        startBtn.disabled = false;
        return;
      }

      // EMA smoothing + hysteresis
      const smoothed = emaUpdate(raw);
      const [sIdx, sP] = applyHysteresis(smoothed);

      // Uppdatera UI med stabil label + (valfritt) top-list på smoothed (ger stabilare lista)
      updateUI(sIdx, sP, smoothed);

      // Infer fps
      if (!inferFpsT0) inferFpsT0 = now;
      inferCount += 1;
      const dtI = now - inferFpsT0;
      if (dtI >= 1000) {
        inferFps = inferCount * 1000 / dtI;
        ifpsEl.textContent = inferFps.toFixed(1);
        inferCount = 0;
        inferFpsT0 = now;
      }
    }

    requestAnimationFrame(loop);
  }

  // =================== EVENTS ===================
  startBtn.addEventListener("click", async () => {
    try {
      startBtn.disabled = true;
      setStatus("Starting…");

      if (!model) await loadModel();
      if (!labels.length) await loadLabels();

      await startCameraRobust();

      // reset smoothing state at start
      ema = null;
      stableIdx = -1;
      candidateIdx = -1;
      candidateStreak = 0;
      lastInferAt = 0;
      inferCount = 0;
      inferFpsT0 = 0;
      ifpsEl.textContent = "—";

      running = true;
      stopBtn.disabled = false;
      setStatus("Camera ready");
      requestAnimationFrame(loop);
    } catch (e) {
      console.error(e);
      setStatus("Error");
      setHint(String(e?.message || e));
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }
  });

  stopBtn.addEventListener("click", () => {
    running = false;
    stopCamera();
    stopBtn.disabled = true;
    startBtn.disabled = false;
    setStatus("Stopped");
  });

  // preload
  (async () => {
    try {
      await loadModel();
      await loadLabels();
      setStatus("Model loaded");
      setHint("Tryck “Starta kamera”. Inference körs ~10 Hz för stabilare resultat.");
    } catch (e) {
      console.warn(e);
      setStatus("Init error");
      setHint(String(e?.message || e));
    }
  })();

  window.addEventListener("resize", () => {
    try { resizeCanvas(); } catch {}
  });
</script>
</body>
</html>
